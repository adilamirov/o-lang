package cup;

import java_cup.runtime.*;

terminal CLASS, EXTENDS, IS, END, VAR, METHOD, THIS, WHILE, LOOP, IF,
         THEN, ELSE, RETURN, LPAREN, RPAREN, LBRACKET, RBRCKET, COMMA,
         DOT, COLON, ASSIGN;
terminal String IDENTIFIER;
terminal String INTEGERLITERAL;
terminal String REALLITERAL;
terminal String BOOLEANLITERAL;

nonterminal Program;
nonterminal ClassDeclaration, MemeberDeclaration, MemeberDeclarations;
nonterminal VariableDeclaration, MethodDeclaration, ConstructorDeclaration;
nonterminal Expression;
nonterminal Parameters, Body;
nonterminal ParameterDeclaration, ParameterDeclarations;
nonterminal Statement;
nonterminal Assignment;
nonterminal WhileLoop, IfStatement, ReturnStatement;
nonterminal ExpressionBody;
nonterminal Arguments;
nonterminal ArgumentExpression;
nonterminal String Primary;

precedence left LPAREN, RPAREN;
precedence right RETURN;

Program ::=
  Program ClassDeclaration:cd    {: System.out.print(cd); :}
| ClassDeclaration:cd            {: System.out.print(cd); :}
;

ClassDeclaration ::=
  CLASS IDENTIFIER:class_id EXTENDS IDENTIFIER:extends_id IS MemeberDeclarations:memdec END  {:
  RESULT = "public class " + class_id + " extends " + extends_id + " { " + memdec + "}"; :}
| CLASS IDENTIFIER:class_name IS MemeberDeclarations:members END  {:
    RESULT = "public class " + class_name + " {\n" + members + "}";
:};

MemeberDeclarations ::=
  MemeberDeclaration:member MemeberDeclarations:members
    {: RESULT = member + "\n" + members; :}
|   {: RESULT = ""; :}
;

MemeberDeclaration ::=
  VariableDeclaration:var           {: RESULT = var; :}
| MethodDeclaration:method          {: RESULT = method; :}
| ConstructorDeclaration:cnstrctr   {: RESULT = cnstrctr; :}
;

VariableDeclaration ::=
  VAR IDENTIFIER:name COLON IDENTIFIER:type   {: RESULT = "public " + type + " " + name + "; "; :}
;


MethodDeclaration ::=
  METHOD IDENTIFIER:name Parameters:args COLON IDENTIFIER:return_type IS Body:body END {:
    RESULT = "public " + return_type + " " + name + args + " { " + body + "}";
  :}
| METHOD IDENTIFIER:name COLON IDENTIFIER:return_type IS Body:body END {:
    RESULT = "public " + return_type + name + " () { " + body + "}";
  :}
| METHOD IDENTIFIER:name Parameters:args IS Body:body END {:
    RESULT = "public void " + name + args + " { " + body + "}";
  :}
;


ConstructorDeclaration ::=
  THIS Parameters:parameters IS Body:body END   {: RESULT = "???"; :}
| THIS IS Body :body END                        {: RESULT = "???"; :}
;


Parameters ::=
  LPAREN ParameterDeclaration:param ParameterDeclarations:params RPAREN {: RESULT = "(" + param + params + ")"; :}
;


ParameterDeclarations ::=
  ParameterDeclarations:params COMMA ParameterDeclaration:param     {: RESULT = params + "," + param; :}
|                                                                   {: RESULT = "" ;:}
;


ParameterDeclaration ::=
  IDENTIFIER:name COLON IDENTIFIER:type   {: RESULT = name + " " + type ;:}
;


Body ::=
  Body:body VariableDeclaration:var {: RESULT = body + "\n" + var ;:}
| Body:body Statement:statement     {: RESULT = body + "\n" + statement;:}
|                                   {: RESULT = ""  ;:}
;

Statement ::=
  Assignment:assignment             {: RESULT = assignment + "\n"; :}
| WhileLoop:whileloop               {: RESULT = whileloop + "\n" ; :}
| IfStatement:ifstatement           {: RESULT = ifstatement + "\n"; :}
| ReturnStatement:returnstatement   {: RESULT = returnstatement + "\n"; :}
;

Assignment ::=
  IDENTIFIER:identifier ASSIGN Expression:expr      {: RESULT = identifier + " = " + expr + ";"; :}
;

WhileLoop ::=
  WHILE Expression:expr LOOP Body:body END    {: RESULT = "while ( " + expr + " ) {\n" + body + "}"; :}
 ;

IfStatement ::=
  IF Expression:expr THEN Body:body_then ELSE Body:body_else END  {:
  RESULT = "if ( " + expr + ") { " + body_then + "} else { " + body_else + "}" ;
  :}
| IF Expression:expr THEN Body:body END {:
RESULT = "if ( " + expr + " ) { " + body + "}"  ;:}
;

ReturnStatement ::=
  RETURN                    {: RESULT = "return;"  ;:}
| RETURN Expression:expr    {: RESULT = "return" + expr + ";"  ;:}
;

Expression ::=
  Primary:prim ExpressionBody:body    {: RESULT = prim + body ;:}
;

ExpressionBody ::=
  ExpressionBody:body DOT IDENTIFIER:id Arguments:arg    {: RESULT = body + "." + id + arg;:}
| ExpressionBody:body DOT IDENTIFIER:id                  {: RESULT = body + "." + id ;:}
|                                                        {: RESULT = ""  ;:}
;

Arguments ::=
  LPAREN Expression:exp ArgumentExpression:aexp RPAREN   {: RESULT = "(" + exp + aexp + ")" ;:}
;

ArgumentExpression ::=
  ArgumentExpression:aexp COMMA Expression:exp  {: RESULT = aexp + ", " + exp  ;:}
|                                               {: RESULT = ""  ;:}
;

Primary ::=
  INTEGERLITERAL:integer    {: RESULT = integer ;:}
| REALLITERAL:real          {: RESULT = real  ;:}
| BOOLEANLITERAL:bool       {: RESULT = bool  ;:}
| THIS                      {: RESULT = "this";:}
| IDENTIFIER:id             {: RESULT = id  ;:}
;
