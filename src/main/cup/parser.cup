package cup;

import java_cup.runtime.*;


parser code {:
    public static String CLASS_NAME;
:}

terminal CLASS, EXTENDS, IS, END, VAR, METHOD, THIS, WHILE, LOOP, IF,
         THEN, ELSE, RETURN, LPAREN, RPAREN, LBRACKET, RBRCKET, COMMA,
         DOT, COLON, ASSIGN;
terminal String IDENTIFIER;
terminal String INTEGERLITERAL;
terminal String REALLITERAL;
terminal String BOOLEANLITERAL;

nonterminal Program;
nonterminal ClassDeclaration, MemeberDeclaration, MemeberDeclarations;
nonterminal VariableDeclaration, MethodDeclaration, ConstructorDeclaration, VariableDeclarationInMethod;
nonterminal Expression;
nonterminal Parameters, Body;
nonterminal ParameterDeclaration, ParameterDeclarations;
nonterminal Statement;
nonterminal Assignment;
nonterminal WhileLoop, IfStatement, ReturnStatement;
nonterminal ExpressionBody;
nonterminal Arguments;
nonterminal ArgumentExpression;
nonterminal String Primary;

precedence left LPAREN, RPAREN;
precedence right RETURN;

Program ::=
  Program:program ClassDeclaration:cd   {: RESULT = program + "" + cd; System.out.print(program + "" + cd); :}
| ClassDeclaration:cd                   {: RESULT = cd + ""; System.out.print("" + cd); :}
;



MemeberDeclarations ::=
  MemeberDeclaration:member MemeberDeclarations:members
    {: RESULT = member + "\n" + members; :}
|   {: RESULT = ""; :}
;

MemeberDeclaration ::=
  VariableDeclaration:var           {: RESULT = var; :}
| MethodDeclaration:method          {: RESULT = method; :}
| ConstructorDeclaration:cnstrctr   {: RESULT = cnstrctr; :}
;

VariableDeclaration ::=
  VAR IDENTIFIER:name COLON Expression:type   {:
    String stype = type.toString();
    if (stype.contains("(")) {
        RESULT = "public " + stype.split("[(]")[0] + " " + name + " = new " + type + ";";
    } else {
        RESULT = "public " + stype + " " + name + " = new " + type + "();";
    }
  :}
;

VariableDeclarationInMethod ::=
  VAR IDENTIFIER:name COLON Expression:type   {:
    String stype = type.toString();
    if (stype.contains("(")) {
        RESULT = stype.split("[(]")[0] + " " + name + " = new " + type + ";";
    } else {
        RESULT = stype + " " + name + " = new " + type + "();";
    }
  :}
;

MethodDeclaration ::=
  METHOD IDENTIFIER:name Parameters:args COLON IDENTIFIER:return_type IS Body:body END {:
    RESULT = "public " + return_type + " " + name + args + " { " + body + "}";
  :}
| METHOD IDENTIFIER:name COLON IDENTIFIER:return_type IS Body:body END {:
    RESULT = "public " + return_type + name + " () { " + body + "}";
  :}
| METHOD IDENTIFIER:name Parameters:args IS Body:body END {:
    RESULT = "public void " + name + args + " { " + body + "}";
  :}
;


ClassDeclaration ::=
  CLASS IDENTIFIER:class_id EXTENDS IDENTIFIER:extends_id IS MemeberDeclarations:members END  {:
  members = members.toString().replaceAll("<CLASSNAME>", class_id);
  RESULT = "public class " + class_id + " extends " + extends_id + " { " + members + "}";
  :}
| CLASS IDENTIFIER:class_id IS MemeberDeclarations:members END  {:
    members = members.toString().replaceAll("<CLASSNAME>", class_id);
    RESULT = "public class " + class_id + " {\n" + members + "}";
:};


ConstructorDeclaration ::=
  THIS Parameters:parameters IS Body:body END   {: RESULT = "public " + "<CLASSNAME>" + parameters + "{\n" + body + "\n}"; :}
| THIS IS Body :body END                        {: RESULT = "public " + "<CLASSNAME>" + "()" + "{\n" + body + "\n}"; :}
;


Parameters ::=
  LPAREN ParameterDeclaration:param ParameterDeclarations:params RPAREN {: RESULT = "(" + param + params + ")"; :}
;


ParameterDeclarations ::=
  ParameterDeclarations:params COMMA ParameterDeclaration:param     {: RESULT = params + "," + param; :}
|                                                                   {: RESULT = "" ;:}
;


ParameterDeclaration ::=
  IDENTIFIER:name COLON IDENTIFIER:type   {: RESULT = type + " " + name ;:}
;


Body ::=
  Body:body VariableDeclarationInMethod:var {: RESULT = body + "\n" + var ;:}
| Body:body Statement:statement     {: RESULT = body + "\n" + statement;:}
|                                   {: RESULT = ""  ;:}
;

Statement ::=
  Assignment:assignment             {: RESULT = assignment + "\n"; :}
| WhileLoop:whileloop               {: RESULT = whileloop + "\n" ; :}
| IfStatement:ifstatement           {: RESULT = ifstatement + "\n"; :}
| ReturnStatement:returnstatement   {: RESULT = returnstatement + "\n"; :}
| Expression:expression             {: RESULT = expression + ";\n"; :}
;

Assignment ::=
  IDENTIFIER:identifier ASSIGN Expression:expr      {: RESULT = identifier + " = " + expr + ";"; :}
;

WhileLoop ::=
  WHILE Expression:expr LOOP Body:body END    {: RESULT = "while ( " + expr + " ) {\n" + body + "}"; :}
 ;

IfStatement ::=
  IF Expression:expr THEN Body:body_then ELSE Body:body_else END  {:
  RESULT = "if ( " + expr + ") { " + body_then + "} else { " + body_else + "}" ;
  :}
| IF Expression:expr THEN Body:body END {:
RESULT = "if ( " + expr + " ) { " + body + "}"  ;:}
;

ReturnStatement ::=
  RETURN                    {: RESULT = "return;"  ;:}
| RETURN Expression:expr    {: RESULT = "return" + expr + ";"  ;:}
;

Expression ::=
  Primary:prim ExpressionBody:body      {: RESULT = prim + body; :}
| Primary:prim Arguments:args           {: RESULT = prim + args; :}
;

ExpressionBody ::=
  ExpressionBody:body DOT IDENTIFIER:id Arguments:arg    {: RESULT = body + "." + id + arg;:}
| ExpressionBody:body DOT IDENTIFIER:id                  {: RESULT = body + "." + id ;:}
|                                                        {: RESULT = ""  ;:}
;

Arguments ::=
  LPAREN Expression:exp ArgumentExpression:aexp RPAREN   {: RESULT = "(" + exp + aexp + ")" ;:}
| LPAREN RPAREN                                          {: RESULT = "()"; :}
;

ArgumentExpression ::=
  ArgumentExpression:aexp COMMA Expression:exp  {: RESULT = aexp + ", " + exp  ;:}
|                                               {: RESULT = ""  ;:}
;

Primary ::=
  INTEGERLITERAL:integer    {: RESULT = integer ;:}
| REALLITERAL:real          {: RESULT = real  ;:}
| BOOLEANLITERAL:bool       {: RESULT = bool  ;:}
| THIS                      {: RESULT = "this";:}
| IDENTIFIER:id             {: RESULT = id  ;:}
;
